#!/usr/bin/env perl
use strict;
use warnings 'all';
use Data::Dumper;
use List::BinarySearch qw( binsearch );

#==========================================================#
# common variables

my @chrom_set = map { "chr$_" } (1..22, "X", "Y");  # only consider: chr1..22, X & Y
my %chrom_set = map { $chrom_set[$_] => $_ } (0 .. $#chrom_set);

my %strand_set = ( '+' => 0, '-' => 1 );

#==========================================================#
# useful functions

sub err
{
	print STDERR "Error: ", @_, "\n";
	exit 1;
}

sub ensure_directory
{
	my @dir_names = split('/', shift);
	for my $i (0 .. $#dir_names) {
		my $path = join("/", @dir_names[0 .. $i]);
		if (not -d $path) {
			print STDERR "Create directory '$path'\n";
			mkdir $path or die;
		}
	}
}

sub compare_genomic_coord
{
	my ($chrom, $pos, $strand, $chrom2, $pos2, $strand2) = @_;
	my $res = $chrom_set{$chrom} <=> $chrom_set{$chrom2};
	if ($res == 0) {
		$res = $pos <=> $pos2;
		if ($res == 0) {
			$res = $strand_set{$strand} <=> $strand_set{$strand2};
		}
	}
	return $res;
}

sub compare_genomic_coord2
{
	my ($a, $b) = @_;
	my ($chrom, $pos, $strand) = split(':', $a, 3);
	my ($chrom2, $pos2, $strand2) = split(':', $b, 3);
	return compare_genomic_coord($chrom, $pos, $strand, $chrom2, $pos2, $strand2);
}

sub compare_genomic_range
{
	my ($p, $q) = @_;
	my $res = $chrom_set{$p->{chrom}} <=> $chrom_set{$q->{chrom}};
	if ($res == 0) {
		$res = $p->{start} <=> $q->{start};
		if ($res == 0) {
			$res = $p->{end} <=> $q->{end};
			if ($res == 0) {
				$res = $strand_set{$p->{strand}} <=> $strand_set{$q->{strand}};
			}
		}
	}
	return $res;
}

sub compare_pos_and_range
{
	my ($a, $b) = @_;
	my $res = $chrom_set{$a->{chrom}} <=> $chrom_set{$b->{chrom}};
	if ($res == 0) {
		if ($a->{pos} < $b->{start}) {
			$res = -1;
		} elsif ($a->{pos} >= $b->{end}) {
			$res = 1;
		}
	}
	return $res;
}

sub rev_comp_seq
{
	my $seq = shift;
	$seq =~ tr/ACGTacgt/TGCAtgca/;
	return reverse $seq;
}

sub load_genome
{
	my $filename = shift;

	my %genome = ();

	print STDERR "Loading genome:";
	open my $file, "<", $filename or die "Failed to read '$filename'";
	my $name;
	while (my $line = <$file>) {
		chomp $line;
		if ($line =~ /^>/) {
			$name = substr($line, 1);
			$name =~ s/\s.*$//;
			$name = '' unless exists $chrom_set{$name};
			print STDERR " $name" if $name;
		} elsif ($name ne '') {
			$genome{$name} .= uc $line;
		}
	}
	close $file;
	print STDERR " done.\n";

	return \%genome;
}

#==========================================================#
# 'collect'

my $def_opt_collect = {
	verbose  => 0,
	input    => '',
	output   => '/dev/stdout',
	min_dist => 1000,
	samtools => 'samtools'
};

sub print_usage_collect
{
	print "
Usage: fuseek collect [options] <in.bam>

Options:
   -h / --help      show this help message
   -v / --verbose   show verbose messages
   -o FILE          output to file rather than stdout [$def_opt_collect->{output}]
   -d INT           minimum distance between discordant read pairs [$def_opt_collect->{min_dist}]
   -s FILE          command or full path of 'samtools' [$def_opt_collect->{samtools}]
   <in.bam>         input (sorted) bam (generated by aligner like 'bwa')

";
	exit 1;
}

sub parse_opt_collect
{
	my %opt = %{$def_opt_collect};  # deep copy

	my @args = ();
	while (my $arg = shift) {
		if ($arg eq '-h' or $arg eq '--help') {
			print_usage_collect
		} elsif ($arg eq '-v' or $arg eq '--verbose') {
			++$opt{verbose};
		} elsif ($arg eq '-o') {
			err "Missing parameter for '$arg'!" unless @_;
			$opt{output} = shift;
		} elsif ($arg eq '-d') {
			err "Missing parameter for '$arg'!" unless @_;
			$opt{min_dist} = shift;
		} elsif ($arg eq '-s') {
			err "Missing parameter for '$arg'!" unless @_;
			$opt{samtools} = shift;
		} else {
			err "Unknown option '$arg'!" if $arg =~ /^-/;
			err "Unexpected parameter '$arg'!" if $#args == 0;
			push @args, $arg;
		}
	}
	print_usage_collect unless $#args == 0;
	($opt{input}) = @args;

	return \%opt;
}

sub do_collect
{
	my $opt = parse_opt_collect @_;

	my $samtools_options = "-F 0x70C";  # filter out: unmapped, secondary, QC-failed, duplicated
	my $command_line = "$opt->{samtools} view $samtools_options $opt->{input}";

	open my $input, "-|", $command_line or die "Failed to view '$opt->{input}'";
	open my $output, ">", $opt->{output} or die "Failed to write '$opt->{output}'";

	print $output join("\t", 'id', 'chrom', 'pos', 'strand', 'chrom2', 'pos2', 'strand2',
		'cigar', 'cigar2', 'seq', 'seq2', 'qual', 'qual2'), "\n";
	my %data = ();
	my $total = 0;
	my $count = 0;
	while (my $line = <$input>) {
		++$total;
		chomp $line;
		my ($id, $flags, $chrom, $pos, $map_qual, $cigar,
			$chrom2, $pos2, $dist, $seq, $qual) = split("\t", $line);

		next if $map_qual == 0;                                    # skip multiple-mapped
		next if $chrom2 eq '=' and abs($dist) < $opt->{min_dist};  # skip concordant
		$chrom2 = $chrom if $chrom2 eq '=';                        # update peer chrom name
		next if not exists $chrom_set{$chrom};                     # skip super-contigs
		next if not exists $chrom_set{$chrom2};                    # skip super-contigs (peer)

		my $strand = (($flags & 0x10) ? '-' : '+');
		my $strand2 = (($flags & 0x20) ? '-' : '+');

		if (not exists $data{$id}) {
			$data{$id} = {
				id => $id, cigar => $cigar, seq => $seq, qual => $qual,
				chrom => $chrom, pos => $pos, strand => $strand,
				chrom2 => $chrom2, pos2 => $pos2, strand2 => $strand2
			};
		} else {
			my $p = $data{$id};
			die "Unmatched pair info for read '$id' in '$opt->{input}'" unless
				$p->{chrom} eq $chrom2 and $p->{pos} == $pos2 and $p->{strand} eq $strand2 and
				$p->{chrom2} eq $chrom and $p->{pos2} == $pos and $p->{strand2} eq $strand;

			if (compare_genomic_coord($chrom, $pos, $strand, $chrom2, $pos2, $strand) <= 0) {
				print $output join("\t", $id, $chrom, $pos, $strand, $chrom2, $pos2, $strand2,
					$cigar, $p->{cigar}, $seq, $p->{seq}, $qual, $p->{qual}), "\n";
			} else {
				print $output join("\t", $id, $chrom2, $pos2, $strand2, $chrom, $pos, $strand,
					$p->{cigar}, $cigar, $p->{seq}, $seq, $p->{qual}, $qual), "\n";
			}
			delete $data{$id};
			$count += 2;
		}
	}
	close $output;
	close $input;

	print STDERR "$total alignment(s) scanned, and $count selected.\n" if $opt->{verbose} > 0;
}

#==========================================================#
# 'identify'

my $def_opt_identify = {
	verbose      => 0,
	input        => '',
	output       => '/dev/stdout',
	genome_fasta => '',
	ref_gene     => '',
	min_clip     => 10,

	seed_size         => 8,
	max_fragment_size => 500,
	max_indel_size    => 3,
	match_for_indel   => 5
};

sub print_usage_identify
{
	print "
Usage: fuseek identify [options] <discord.txt> <ref.fa>

Options:
   -h / --help      show this help message
   -v / --verbose   show verbose messages
   -o FILE          output to file rather than stdout [$def_opt_identify->{output}]
   -r FILE          path of UCSC ref-gene annotation file
   -m INT           minimum size of soft clipping for breakpoint inferring [$def_opt_identify->{min_clip}]
   <discord.txt>    input text file (generated by 'collect')

";
	exit 1;
}

sub parse_opt_identify
{
	my %opt = %{$def_opt_identify};  # deep copy

	my @args = ();
	while (my $arg = shift) {
		if ($arg eq '-h' or $arg eq '--help') {
			print_usage_identify
		} elsif ($arg eq '-v' or $arg eq '--verbose') {
			++$opt{verbose};
		} elsif ($arg eq '-o') {
			err "Missing parameter for '$arg'!" unless @_;
			$opt{output} = shift;
		} elsif ($arg eq '-r') {
			err "Missing parameter for '$arg'!" unless @_;
			$opt{ref_gene} = shift;
		} elsif ($arg eq '-m') {
			err "Missing parameter for '$arg'!" unless @_;
			$opt{min_clip} = shift;
		} else {
			err "Unknown option '$arg'!" if $arg =~ /^-/;
			err "Unexpected parameter '$arg'!" if $#args == 1;
			push @args, $arg;
		}
	}
	print_usage_identify unless $#args == 1;
	($opt{input}, $opt{genome_fasta}) = @args;

	return \%opt;
}

sub load_genes
{
	my $filename = shift;

	open my $file, "-|", "zcat $filename" or die "Cannot read file '$filename'";
	<$file>; # skip first line
	my @genes = sort {
			compare_genomic_range($a, $b)
		} grep {
			exists $chrom_set{$_->{chrom}}
		} map {
			my @s = split "\t";
			{
				chrom => $s[2], start => $s[4], end => $s[5], strand => $s[3],
				gene => $s[12], transcript => $s[1]
			}
		} <$file>;
	close $file;

	return \@genes;
}

sub infer_breakpoint
{
	my ($p, $min_clip) = @_;
	if ($p->{strand} eq '+' and $p->{cigar} =~ /^((([0-9]+)[MID])+)([0-9]+)S$/) {
		my $non_clip_cigar = $1;
		my $clipped = $4;
		if ($clipped >= $min_clip) {
			my $breakpoint = $p->{pos};
			while ($non_clip_cigar =~ /([0-9]+)[MD]/g) {
				$breakpoint += $1;
			}
			return $breakpoint;
		}
	} elsif ($p->{strand} eq '-' and $p->{cigar} =~ /^([0-9]+)S(([0-9]+)[MID])+$/) {
		my $clipped = $1;
		if ($clipped >= $min_clip) {
			return $p->{pos};
		}
	}
	return '-';
}

sub load_breakpoint_supports
{
	my ($filename, $min_clip) = @_;

	my @input_cols = ('id', 'chrom', 'pos', 'strand', 'chrom2', 'pos2', 'strand2',
		'cigar', 'cigar2', 'seq', 'seq2', 'qual', 'qual2');

	open my $file, "<", $filename or die "Failed to read '$filename'";
	my $line_no = 0;
	my %data = ();
	while (my $line = <$file>) {
		chomp $line;
		if (++$line_no == 1) {
			die "Unexpected columns in '$filename'" if $line ne join("\t", @input_cols);
			next;
		}
		my @s = split("\t", $line);
		die "Unexpected column count at line $line_no in '$filename'" if $#s != $#input_cols;

		my %f = map { $input_cols[$_] => $s[$_] } (0 .. $#s);

		my $breakpoint = infer_breakpoint { strand => $f{strand}, cigar => $f{cigar}, pos => $f{pos} }, $min_clip;
		my $breakpoint2 = infer_breakpoint { strand => $f{strand2}, cigar => $f{cigar2}, pos => $f{pos2} }, $min_clip;

		if ($breakpoint ne '-') {
			my $key = join(':', $f{chrom}, $breakpoint, $f{strand});
			push @{$data{$key}->{$f{pos}}}, { id => $f{id}, end => 1, seq => $f{seq}, qual => $f{qual} };
		}
		if ($breakpoint2 ne '-') {
			my $key = join(':', $f{chrom2}, $breakpoint2, $f{strand2});
			push @{$data{$key}->{$f{pos2}}}, { id => $f{id}, end => 2, seq => $f{seq2}, qual => $f{qual2} };
		}
	}
	close $file;

	return \%data;
}

sub do_identify
{
	my $opt = parse_opt_identify @_;

	my $breakpoint_supports = load_breakpoint_supports $opt->{input}, $opt->{min_clip};
#print Dumper $breakpoint_supports;

	my $genes = load_genes $opt->{ref_gene} if $opt->{ref_gene};

	my %candidate_breakpoints = ();
	for my $key (sort{ compare_genomic_coord2($a, $b) }keys %{$breakpoint_supports}) {
		my ($chrom, $pos, $strand) = split(':', $key);
		my $supports = $breakpoint_supports->{$key};
		my $supportingReads = 0;
		for my $pos (keys %{$breakpoint_supports->{$key}}) {
			$supportingReads += scalar @{$breakpoint_supports->{$key}->{$pos}};
		}

		my $gene = '-';
		my $transcript = '-';
		if ($opt->{ref_gene}) {
			my $current = { chrom => $chrom, pos => $pos };
			my $index = binsearch { compare_pos_and_range($a, $b) } $current, @{$genes};
			if (defined $index) {
				my %gene_results = ();
				for (; $index < scalar @{$genes}; ++$index) {
					my $item = $genes->[$index];
					last if compare_pos_and_range $current, $item;
					$gene_results{$item->{gene}}->{$item->{transcript}}++;
				}
				if (%gene_results) {
					$gene = join(";", sort keys %gene_results);
					$transcript = join(";", map{ join(",", sort keys %{$gene_results{$_}}) } sort keys %gene_results);
				}
			}
		}

		next if scalar keys %{$supports} < 2;
		next if $opt->{ref_gene} ne '' and $gene eq '-';

		$candidate_breakpoints{$chrom}->{$pos}->{$strand} = 1;
	}
#print Dumper \%candidate_breakpoints;
	print "Candidate breakpings: ", scalar keys %{candidate_breakpoints}, "\n";

	sub match
	{
		my ($a, $i, $b, $j, $n) = @_;

		return 0 if $i + $n > scalar @{$a};
		return 0 if $j + $n > scalar @{$b};

		for my $k (0 .. ($n - 1)) {
			return 0 if $a->[$i + $k] ne $b->[$j + $k];
		}
		return 1;
	}

	sub extend
	{
		my ($target, $query, $opt) = @_;

		my @t = split("", $target);
		my @q = split("", $query);

		my $max_allowed_mismatch = int(scalar(@q) * 0.1);  # allow 10% mismatch
		my $max_allowed_indel = int(scalar(@q) * 0.05);    # allow 5% indel

		my $mismatch = 0;
		my $indel = 0;
		my $i = 0;
		my $j = 0;
		while ($i <= $#t and $j <= $#q) {
			if ($t[$i] eq $q[$j]) {
				++$i; ++$j;
			} else {
				++$mismatch;
				return 0 if $mismatch > $max_allowed_mismatch;
				my $ok = 0;
				if ($indel < $max_allowed_indel) {
					for my $try_indel (1 .. $opt->{max_indel_size}) {
						if (match(\@t, $i + $try_indel, \@q, $j, $opt->{match_for_indel})) {
							++$indel;
							$i += $try_indel + $opt->{match_for_indel};
							$j += $opt->{match_for_indel};
							$ok = 1;
							last;
						}
						if (match(\@t, $i, \@q, $j + $try_indel, $opt->{match_for_indel})) {
							++$indel;
							$i += $opt->{match_for_indel};
							$j += $try_indel + $opt->{match_for_indel};
							$ok = 1;
							last;
						}
					}
				}
				if (!$ok) {
					++$i; ++$j;
				}
			}
		}
		return ($j >= $#q);
	}

	sub align
	{
		my ($target, $query, $opt) = @_;

		my $target_size = length($target);
		my $query_size = length($query);

		my $seed = $query;  # first n bases that should match exactly (to determine breakpoint)
		my $rest = '';
		if ($query_size > $opt->{seed_size}) {
			$seed = substr($query, 0, $opt->{seed_size});
			$rest = substr($query, $opt->{seed_size});
		}

		for my $pos (0 .. ($target_size - $query_size)) {
			if (substr($target, $pos, $opt->{seed_size}) eq $seed) {  # exact-matched
				if ($rest eq '' or extend(substr($target, $pos + $opt->{seed_size}), $rest, $opt)) {
					return $pos;
				}
			}
		}
		return undef;
	}

	sub check_overlap
	{
		my ($seq, $strand, $seq2, $strand2, $opt) = @_;

		my $seq_len = length($seq);
		die if $seq_len != length($seq2);

		# convert back to original as in .fastq
		$seq = rev_comp_seq($seq) if $strand eq '-';
		$seq2 = rev_comp_seq($seq2) if $strand2 eq '-';

		my $rseq2 = rev_comp_seq($seq2);  # rev-comp to compare

		for (my $len = $seq_len; $len >= 10; --$len) {
			my $x = align(substr($seq, 0, $len), substr($rseq2, $seq_len - $len, $len), $opt);
			if (defined $x) {
				return $len;
			}
		}
		return undef;
	}

	my %breakpoints = ();

	sub add_breakpoint
	{
		my ($breakpoints_ref, $chrom, $pos, $strand, $chrom2, $pos2, $strand2, $id) = @_;

		my $key = join(':', $chrom, $pos, $strand);
		my $key2 = join(':', $chrom2, $pos2, $strand2);
		if (compare_genomic_coord2($key, $key2) <= 0) {
			($key, $key2) = ($key2, $key);
		}
		$breakpoints_ref->{$key}->{$key2}->{$id}++;
	}

	sub try_split_and_align
	{
		my ($genome, $chrom, $pos, $strand, $breakpoint, $seq, $cigar, $chrom2, $pos2, $strand2, $seq2, $id, $opt, $breakpoints_ref) = @_;

		my $o = check_overlap($seq, $strand, $seq2, $strand2, $opt);
		if (defined $o) {
			$seq = substr($seq, 0, $o);
		}

		my $query;
		if ($strand eq '+') {
			my $query_clipped = 0;
			if ($cigar =~ /([0-9]+)S$/) {
				$query_clipped += $1;
			}
			$query = substr($seq, length($seq) - $query_clipped);
		} else {
			my $query_clipped = 0;
			if ($cigar =~ /^([0-9]+)S/) {
				$query_clipped += $1;
			}
			$query = rev_comp_seq(substr($seq, 0, $query_clipped));
		}

		my $target;
		if ($strand2 eq '+') {
			$target = substr($genome->{$chrom2}, $pos2, $opt->{max_fragment_size});
		} else {
			$target = substr($genome->{$chrom2}, $pos2 + length($seq2) - $opt->{max_fragment_size}, $opt->{max_fragment_size});
		}
		if ($strand eq $strand2) {
			$target = rev_comp_seq($target);
		}

		my $x = align($target, $query, $opt);
		if (defined $x) {
			my $breakpoint2;
			if ($strand2 eq '+') {
				$breakpoint2 = $pos2 + $x;
			} else {
				$breakpoint2 = $pos2 - $x;
			}
			add_breakpoint $breakpoints_ref, $chrom, $breakpoint, $strand, $chrom2, $breakpoint2, $strand2, $id;
		}
	}

	sub process_paired_reads
	{
		my ($filename, $opt, $breakpoints_ref, $candidate_breakpoints_ref, $genome) = @_;

		open my $file, "<", $filename or die "Failed to read '$filename'";
		<$file>;  # skip first line
		while (my $line = <$file>) {
			chomp $line;
			my ($chrom, $pos, $strand, $breakpoint, $cigar,
				$chrom2, $pos2, $strand2, $breakpoint2, $cigar2,
				$id, $seq, $seq2, $qual, $qual2) = split("\t", $line);

			if ($breakpoint ne '-' and exists $candidate_breakpoints_ref->{$chrom}->{$breakpoint}->{$strand}) {
				try_split_and_align $genome, $chrom, $pos, $strand, $breakpoint, $seq, $cigar, $chrom2, $pos2, $strand2, $seq2, $id, $opt, $breakpoints_ref;
			}
			if ($breakpoint2 ne '-' and exists $candidate_breakpoints_ref->{$chrom2}->{$breakpoint2}->{$strand2}) {
				try_split_and_align $genome, $chrom2, $pos2, $strand2, $breakpoint2, $seq2, $cigar2, $chrom, $pos, $strand, $seq, $id, $opt, $breakpoints_ref;
			}
		}
		close $file;
	}

	my $genome = load_genome $opt->{genome_fasta};
	process_paired_reads $opt->{input}, $opt, \%breakpoints, \%candidate_breakpoints, $genome;

	open my $output, ">", $opt->{output} or die "Failed to write '$opt->{output}'";
	my @output_cols = ('chrom', 'pos', 'strand', 'chrom2', 'pos2', 'strand2', 'id');
	print $output join("\t", @output_cols), "\n";
	for my $key (sort { compare_genomic_coord2($a, $b) } keys %breakpoints) {
		for my $key2 (sort { compare_genomic_coord2($a, $b) } keys %{$breakpoints{$key}}) {
			for my $id (sort keys %{$breakpoints{$key}->{$key2}}) {
				print $output join("\t", split(':', $key), split(':', $key2), $id), "\n";
			}
		}
	}
	close $output;
}

#==========================================================#
# 'refine'

sub print_usage_refine
{
	print "
Usage: fuseek refine [options] <candidates.txt>

Options:
   -h / --help       show this help message
   -v / --verbose    show verbose messages
   <candidates.txt>  input text file (generated by 'identify')

Note:
   This step is supposed to refine fusion results (including breakpoints) by realignment.

";
	exit 1;
}

sub do_refine
{
	print_usage_refine unless @_;

	err "'refine' is still under development!"
}

#==========================================================#
# 'annotate'

sub print_usage_annotate
{
	print "
Usage: fuseek annotate [options] <fusions.txt>

Options:
   -h / --help     show this help message
   -v / --verbose  show verbose messages
   <fusions.txt>   input text file (generated by 'refine')

Note:
   This step is supposed to generate annotation (gene info) on fusion flunkings.

";
	exit 1;
}

sub do_annotate
{
	print_usage_annotate unless @_;

	err "'annotate' is still under development!"
}

#==========================================================#
# 'run'

my $def_opt_run = {
	verbose    => 0,
	input_bam  => '',
	out_prefix => ''
};

sub print_usage_run
{
	print "
Usage: fuseek run [options] <ref.fa> <genes.gz> <in.bam> <out-prefix>

Options:
   -h / --help     show this help message
   -v / --verbose  show verbose messages
   <ref.fa>        reference genome in FASTA format
   <genes.gz>      gene annotation files (such as 'refGene.gz' downloaded from UCSC)
   <in.bam>        input (sorted) bam (generated by aligner like 'bwa')
   <out-prefix>    prefix (may contains directory name) of output files

";
	exit 1;
}

sub parse_opt_run
{
	my %opt = %{$def_opt_run};  # deep copy

	my @args = ();
	while (my $arg = shift) {
		if ($arg eq '-h' or $arg eq '--help') {
			print_usage_run
		} elsif ($arg eq '-v' or $arg eq '--verbose') {
			++$opt{verbose};
		} else {
			err "Unknown option '$arg'!" if $arg =~ /^-/;
			err "Unexpected parameter '$arg'!" if $#args == 3;
			push @args, $arg;
		}
	}
	print_usage_run unless $#args == 3;
	($opt{genome}, $opt{ref_gene}, $opt{input_bam}, $opt{out_prefix}) = @args;

	return \%opt;
}

sub do_run
{
	my $opt = parse_opt_run @_;

	my $dir = $opt->{out_prefix};
	if ($dir =~ /\//) {
		$dir =~ s/\/[^\/]*$//;
		ensure_directory $dir if $dir;
	}

	my $file0 = $opt->{input_bam};

	my $file1 = "$opt->{out_prefix}.01-discord.txt";
	die unless -e $file0;
	if (not -e $file1 or -M $file0 < -M $file1) {
		print STDERR "Generating '$file1'...\n";
		do_collect $file0, '-o', $file1;
	}

	my $file2 = "$opt->{out_prefix}.02-candidate.txt";
	die unless -e $file1;
	if (not -e $file2 or -M $file1 < -M $file2) {
		print STDERR "Generating '$file2'...\n";
		do_identify $file1, '-o', $file2, '-r', $opt->{ref_gene}, $opt->{genome};
	}

	print STDERR "Done.\n";
}

#==========================================================#

my $version = "0.0.1";

sub print_usage
{
	print "
Program: fuseek (FUsion SEEKer)
Version: $version

Usage:   fuseek <command> [options]

Commands:
   run        batch run (collect, identify, refine, annotate)
   collect    collect discordant reads from BAM file
   identify   identify fusions from discordant reads
   refine     refine breakpoints of fusions
   annotate   annotate fusions

";
	exit 1;
}

#----------------------------------------------------------#

print_usage unless @ARGV;

my %proc = (
	collect  => \&do_collect,
	identify => \&do_identify,
	refine   => \&do_refine,
	annotate => \&do_annotate,
	run      => \&do_run,
	version  => sub { print $version, "\n"; }
);

my $cmd = shift;
err "Unknown command '$cmd'!" unless exists $proc{$cmd};
exit $proc{$cmd}->(@ARGV);
