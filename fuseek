#!/usr/bin/env perl
use strict;
use warnings 'all';
use Data::Dumper;
use File::Temp qw/ :POSIX /;
use List::BinarySearch qw( binsearch );

#==========================================================#
# common variables

my @chrom_set = map { "chr$_" } (1..22, "X", "Y");  # only consider: chr1..22, X & Y
my %chrom_order = map { $chrom_set[$_] => $_ } (0 .. $#chrom_set);

my %strand_order = ( '+' => 0, '-' => 1 );

#==========================================================#
# useful functions

sub err
{
	print STDERR "Error: ", @_, "\n";
	exit 1;
}

sub prep_dir
{
	my @dir_names = split('/', shift);  # split path to names of each level
	pop @dir_names;                     # drop last one (file name but not dir name)
	if (@dir_names) {
		for my $i (0 .. $#dir_names) {
			my $path = join('/', @dir_names[0 .. $i]);
			if (not -d $path) {
				mkdir $path or err "Failed to create directory '$path'";
			}
		}
	}
}

sub time_str
{
	my $timestap = shift;
	my ($sec, $min, $hour, $mday, $mon, $year, $wday, $yday, $isdst) = localtime $timestap;
	return sprintf '%04d-%02d-%02d %02d:%02d:%02d', $year + 1900, $mon, $mday, $hour, $min, $sec;
}

#----------------------------------------------------------#

sub compare_genomic_coord
{
	my ($chrom, $pos, $strand, $chrom2, $pos2, $strand2) = @_;
	my $res = $chrom_order{$chrom} <=> $chrom_order{$chrom2};
	if ($res == 0) {
		$res = $pos <=> $pos2;
		if ($res == 0) {
			$res = $strand_order{$strand} <=> $strand_order{$strand2};
		}
	}
	return $res;
}

sub compare_genomic_coord2
{
	my ($a, $b) = @_;
	my ($chrom, $pos, $strand) = split(':', $a, 3);
	my ($chrom2, $pos2, $strand2) = split(':', $b, 3);
	return compare_genomic_coord($chrom, $pos, $strand, $chrom2, $pos2, $strand2);
}

sub compare_genomic_range
{
	my ($p, $q) = @_;
	my $res = $chrom_order{$p->{chrom}} <=> $chrom_order{$q->{chrom}};
	if ($res == 0) {
		$res = $p->{start} <=> $q->{start};
		if ($res == 0) {
			$res = $p->{end} <=> $q->{end};
			if ($res == 0) {
				$res = $strand_order{$p->{strand}} <=> $strand_order{$q->{strand}};
			}
		}
	}
	return $res;
}

sub compare_pos_and_range
{
	my ($a, $b) = @_;
	my $res = $chrom_order{$a->{chrom}} <=> $chrom_order{$b->{chrom}};
	if ($res == 0) {
		if ($a->{pos} < $b->{start}) {
			$res = -1;
		} elsif ($a->{pos} >= $b->{end}) {
			$res = 1;
		}
	}
	return $res;
}

sub rev_comp_seq
{
	my $seq = shift;
	$seq =~ tr/ACGTacgt/TGCAtgca/;
	return scalar reverse $seq;
}

#----------------------------------------------------------#

sub load_tsv
{
	my ($filename, $col_names) = @_;

	my $is_gz = $filename =~ /\.gz$/;
	my $mode = $is_gz ? '-|' : '<';
	my $name = ($is_gz ? 'zcat ' : '') . $filename;

	open my $file, $mode, $name or err "Failed to read '$filename'";
	my @data = ();
	my $line_no = 0;
	while (my $line = <$file>) {
		++$line_no;
		chomp $line;
		if ($line_no == 1) {
			if (defined $col_names) {
				err "Unexpected column names in '$filename':\n"
					. "  Exp.: " . join("\t", @{$col_names}) . "\n"
					. "  Obs.: " . $line
					if $line ne join("\t", @{$col_names});
			} else {
				$col_names = [ split("\t", $line) ];
			}
		} else {
			my @values = split("\t", $line);
			err "Unmatched column count in line $line_no of '$filename'" if scalar @values != scalar @{$col_names};
			push @data, { map { $col_names->[$_] => $values[$_] } 0 .. $#values };
		}
	}
	close $file;

	return { names => $col_names, data => \@data };
}

#----------------------------------------------------------#

sub load_genome  # fasta file
{
	my ($filename, $verbose) = @_;

	print STDERR "Loading genome:" if $verbose > 1;
	open my $file, "<", $filename or err "Failed to read '$filename'";
	my %genome = ();
	my $name;
	my $chromosomes = 0;
	my $bases = 0;
	while (my $line = <$file>) {
		chomp $line;
		if ($line =~ /^>/) {
			$name = substr($line, 1);
			$name =~ s/\s.*$//;
			$name = '' unless exists $chrom_order{$name};
			print STDERR " $name" if $name and $verbose > 1;
			$chromosomes++;
		} elsif ($name ne '') {
			$genome{$name} .= uc $line;
			$bases += length $line;
		}
	}
	close $file;
	print STDERR ".\n  In total, $chromosomes chromosome(s), $bases base(s) loaded.\n" if $verbose > 1;

	return \%genome;
}

sub load_genes  # gzipped-tsv file, downloaded from UCSC table browser, such as 'refGene'
{
	my $filename = shift;
	my $col_names = [ '#bin', 'name', 'chrom', 'strand', 'txStart', 'txEnd', 'cdsStart', 'cdsEnd',
		'exonCount', 'exonStarts', 'exonEnds', 'score', 'name2', 'cdsStartStat', 'cdsEndStat', 'exonFrames' ];
	my $data = load_tsv $filename, $col_names;
	my @genes = sort {
			compare_genomic_range($a, $b)
		} grep {
			exists $chrom_order{$_->{chrom}}
		} map {
			my $exonCount = $_->{exonCount};
			my @exonStarts = ();
			my @exonEnds = ();
			my $tx_size = 0;
			if ($exonCount > 0) {
				@exonStarts = (split(',', $_->{exonStarts}))[0 .. ($exonCount - 1)];
				@exonEnds = (split(',', $_->{exonEnds}))[0 .. ($exonCount - 1)];
				for (my $i = 0; $i < $exonCount; ++$i) {
					$tx_size += $exonEnds[$i] - $exonStarts[$i];
				}
			}
			{
				chrom => $_->{chrom}, start => $_->{txStart}, end => $_->{txEnd},
				strand => $_->{strand}, gene => $_->{name2}, transcript => $_->{name},
				cdsStart => $_->{cdsStart}, cdsEnd => $_->{cdsEnd},
				exonCount => $exonCount, exonStarts => \@exonStarts, exonEnds => \@exonEnds,
				tx_size => $tx_size
			}
		} @{$data->{data}};
	return \@genes;
}

#----------------------------------------------------------#

sub match
{
	my ($a, $i, $b, $j, $n) = @_;

	return 0 if $i + $n > scalar @{$a};
	return 0 if $j + $n > scalar @{$b};

	for my $k (0 .. ($n - 1)) {
		return 0 if $a->[$i + $k] ne $b->[$j + $k];
	}
	return 1;
}

sub extend
{
	my ($target, $query, $opt) = @_;

	my @t = split("", $target);
	my @q = split("", $query);

	my $max_allowed_mismatch = int(scalar(@q) * 0.1);  # allow 10% mismatch
	my $max_allowed_indel = int(scalar(@q) * 0.05);    # allow 5% indel

	my $mismatch = 0;
	my $indel = 0;
	my $i = 0;
	my $j = 0;
	while ($i <= $#t and $j <= $#q) {
		if ($t[$i] eq $q[$j]) {
			++$i; ++$j;
		} else {
			++$mismatch;
			return 0 if $mismatch > $max_allowed_mismatch;
			my $ok = 0;
			if ($indel < $max_allowed_indel) {
				for my $try_indel (1 .. $opt->{max_indel_size}) {
					if (match(\@t, $i + $try_indel, \@q, $j, $opt->{match_for_indel})) {
						++$indel;
						$i += $try_indel + $opt->{match_for_indel};
						$j += $opt->{match_for_indel};
						$ok = 1;
						last;
					}
					if (match(\@t, $i, \@q, $j + $try_indel, $opt->{match_for_indel})) {
						++$indel;
						$i += $opt->{match_for_indel};
						$j += $try_indel + $opt->{match_for_indel};
						$ok = 1;
						last;
					}
				}
			}
			if (!$ok) {
				++$i; ++$j;
			}
		}
	}
	return ($j >= $#q);
}

sub align
{
	my ($target, $query, $opt) = @_;

	my $target_size = length($target);
	my $query_size = length($query);

	my $seed = $query;  # first n bases that should match exactly (to determine breakpoint)
	my $rest = '';
	if ($query_size > $opt->{seed_size}) {
		$seed = substr($query, 0, $opt->{seed_size});
		$rest = substr($query, $opt->{seed_size});
	}

	for my $pos (0 .. ($target_size - $query_size)) {
		if (substr($target, $pos, $opt->{seed_size}) eq $seed) {  # exact-matched
			if ($rest eq '' or extend(substr($target, $pos + $opt->{seed_size}), $rest, $opt)) {
				return $pos;
			}
		}
	}
	return undef;
}

sub check_overlap
{
	my ($seq, $strand, $seq2, $strand2, $opt) = @_;

	my $seq_len = length($seq);
	die if $seq_len != length($seq2);

	# convert back to original as in .fastq
	$seq = rev_comp_seq($seq) if $strand eq '-';
	$seq2 = rev_comp_seq($seq2) if $strand2 eq '-';

	my $rseq2 = rev_comp_seq($seq2);  # rev-comp to compare

	for (my $len = $seq_len; $len >= 10; --$len) {
		my $x = align(substr($seq, 0, $len), substr($rseq2, $seq_len - $len, $len), $opt);
		if (defined $x) {
			if ($opt->{verbose} > 1) {
				print STDERR "Found overlap between PE reads: ($len bp, x = $x)\n";
				print STDERR '   ', (' ' x (length($seq) - $len)), "5'-", $seq, "-3'\n";
				print STDERR '   ', "3'-", scalar reverse($seq2), "-5'\n";
			}
			return $len;
		}
	}
	return undef;
}

#==========================================================#
# command 'collect'

my $def_opt_collect = {
	verbose  => 0,
	input    => '',
	output   => '/dev/stdout',
	regions  => '',
	min_dist => 1000,
	samtools => 'samtools'
};

sub print_usage_collect
{
	print "
Usage: fuseek collect [options] <in.bam> [discord.txt]

Options:
   <in.bam>        input bam file (generated by aligner like 'bwa')
   [discord.txt]   output TAB-sep text file of discordant reads [$def_opt_collect->{output}]
   -d INT          minimum distance between discordant read pairs [$def_opt_collect->{min_dist}]
   -b FILE         BED file of interest regions [null]
   -s FILE         command or full path of 'samtools' [$def_opt_collect->{samtools}]
   -v              show verbose messages
   -h / --help     show this help message

";
	exit 1;
}

sub parse_opt_collect
{
	my %opt = %{$def_opt_collect};  # deep copy

	my @args = ();
	while (my $arg = shift) {
		if ($arg eq '-d') {
			err "Missing parameter for '$arg'!" unless @_;
			$opt{min_dist} = shift;
		} elsif ($arg eq '-b') {
			err "Missing parameter for '$arg'!" unless @_;
			$opt{regions} = shift;
		} elsif ($arg eq '-s') {
			err "Missing parameter for '$arg'!" unless @_;
			$opt{samtools} = shift;
		} elsif ($arg eq '-v') {
			++$opt{verbose};
		} elsif ($arg eq '-h' or $arg eq '--help') {
			print_usage_collect;
		} else {
			err "Unknown option '$arg'!" if $arg =~ /^-/;
			err "Unexpected parameter '$arg'!" if scalar @args > 2;
			push @args, $arg;
		}
	}
	print_usage_collect if scalar @args < 1;
	$opt{input} = shift @args;
	$opt{output} = shift @args if @args;

	return \%opt;
}

sub do_collect
{
	my $opt = parse_opt_collect @_;

	my $samtools_options = "-F 0xF00";  # filter out: secondary (0x100), QC-failed (0x200), duplicated (0x400), supplementary (0x800)
	$samtools_options .= " -L $opt->{regions}" if $opt->{regions};
	my $command_line = "$opt->{samtools} view $samtools_options $opt->{input}";

	open my $input, "-|", $command_line or err "Failed to view '$opt->{input}'";
	open my $output, ">", $opt->{output} or err "Failed to write '$opt->{output}'";

	my $last_time = time;
	my $last_total = 0;
	print $output join("\t",
		'id', 'chrom', 'pos', 'strand', 'chrom2', 'pos2', 'strand2',
		'cigar', 'cigar2', 'seq', 'seq2', 'qual', 'qual2'), "\n";
	my %data = ();
	my $total = 0;
	my $count = 0;
	while (my $line = <$input>) {
		++$total;
		chomp $line;
		my ($id, $flags, $chrom, $pos, $map_qual, $cigar,
			$chrom2, $pos2, $dist, $seq, $qual) = split("\t", $line);

		next if $map_qual == 0;                                    # skip multiple-mapped
		next if $chrom2 eq '=' and abs($dist) < $opt->{min_dist};  # skip concordant
		$chrom2 = $chrom if $chrom2 eq '=';                        # update peer chrom name
		next if not exists $chrom_order{$chrom};                   # skip super-contigs
		next if not exists $chrom_order{$chrom2};                  # skip super-contigs (peer)

		my $strand = (($flags & 0x10) ? '-' : '+');
		my $strand2 = (($flags & 0x20) ? '-' : '+');

		if (not exists $data{$id}) {
			$data{$id} = {
				id => $id, cigar => $cigar, seq => $seq, qual => $qual,
				chrom => $chrom, pos => $pos, strand => $strand,
				chrom2 => $chrom2, pos2 => $pos2, strand2 => $strand2
			};
		} else {
			my $p = $data{$id};
			err "Unmatched pair info for read '$id' in '$opt->{input}'" unless
				$p->{chrom} eq $chrom2 and $p->{pos} == $pos2 and $p->{strand} eq $strand2 and
				$p->{chrom2} eq $chrom and $p->{pos2} == $pos and $p->{strand2} eq $strand;

			if (compare_genomic_coord($chrom, $pos, $strand, $chrom2, $pos2, $strand) <= 0) {
				print $output join("\t", $id, $chrom, $pos, $strand, $chrom2, $pos2, $strand2,
					$cigar, $p->{cigar}, $seq, $p->{seq}, $qual, $p->{qual}), "\n";
			} else {
				print $output join("\t", $id, $chrom2, $pos2, $strand2, $chrom, $pos, $strand,
					$p->{cigar}, $cigar, $p->{seq}, $seq, $p->{qual}, $qual), "\n";
			}
			delete $data{$id};
			$count += 2;
		}

		if ($opt->{verbose} > 1 and $total - $last_total >= 100000) {
			my $now = time;
			if ($now - $last_time >= 10) {
				printf STDERR '[' . time_str($now) . "] $total alignments scanned, and $count selected.         \r",
				$last_time = $now;
				$last_total = $total;
			}
		}
	}
	close $output;
	close $input;

	printf STDERR "\n[" . time_str(time) . '] ' if $opt->{verbose} > 1 and $last_total > 0;
	print STDERR "All $total alignment(s) scanned, and $count selected.\n" if $opt->{verbose} > 0;

	return 0;
}

#==========================================================#
# command 'identify'

my $def_opt_identify = {
	verbose  => 0,
	input    => '',
	output   => '/dev/stdout',
	genome   => '',
	min_clip => 10,
	min_supp => 2,

	seed_size         => 8,     # 'seed' is for exact-matching at beginning of two sequences to align
	max_fragment_size => 1000,  # search space (expand to downstream) for peer read
	rev_expand_size   => 100,   # search space (expand to upstream) for peer read
	max_indel_size    => 3,     # maximum indel size to search
	match_for_indel   => 5      # how many bases required to match exactly after indel
};

sub print_usage_identify
{
	print "
Usage: fuseek identify [options] <ref.fa> <discord.txt> [breakpoints.txt]

Options:
   <ref.fa>            reference genome in FASTA format
   <discord.txt>       input text file (generated by 'collect')
   [breakpoints.txt]   output TAB-sep text file of cancidate breakpoints [$def_opt_identify->{output}]
   -m INT              minimum size of soft clipping for breakpoint inferring [$def_opt_identify->{min_clip}]
   -s INT              minimum supports of different reads for a breakpoint [$def_opt_identify->{min_supp}]
   -v                  show verbose messages
   -h / --help         show this help message

";
	exit 1;
}

sub parse_opt_identify
{
	my %opt = %{$def_opt_identify};  # deep copy

	my @args = ();
	while (my $arg = shift) {
		if ($arg eq '-m') {
			err "Missing parameter for '$arg'!" unless @_;
			$opt{min_clip} = shift;
		} elsif ($arg eq '-s') {
			err "Missing parameter for '$arg'!" unless @_;
			$opt{min_supp} = shift;
		} elsif ($arg eq '-v') {
			++$opt{verbose};
		} elsif ($arg eq '-h' or $arg eq '--help') {
			print_usage_identify;
		} else {
			err "Unknown option '$arg'!" if $arg =~ /^-/;
			err "Unexpected parameter '$arg'!" if scalar @args >= 3;
			push @args, $arg;
		}
	}
	print_usage_identify if scalar @args < 2;
	$opt{genome} = shift @args;
	$opt{input} = shift @args;
	$opt{output} = shift @args if @args;

	return \%opt;
}

sub get_breakpoint_supports
{
	my ($discord) = @_;

	my %data = ();
	for my $p (@{$discord}) {
		if ($p->{breakpoint} ne '-') {
			my $key = join(':', $p->{chrom}, $p->{breakpoint}, $p->{strand});
			push @{$data{$key}->{$p->{pos}}}, { id => $p->{id}, end => 1, seq => $p->{seq}, qual => $p->{qual} };
		}
		if ($p->{breakpoint2} ne '-') {
			my $key = join(':', $p->{chrom2}, $p->{breakpoint2}, $p->{strand2});
			push @{$data{$key}->{$p->{pos2}}}, { id => $p->{id}, end => 2, seq => $p->{seq2}, qual => $p->{qual2} };
		}
	}
	return \%data;
}

sub try_split_and_align
{
	my ($output, $genome, $chrom, $pos, $strand, $breakpoint, $seq, $cigar, $chrom2, $pos2, $strand2, $cigar2, $id, $opt) = @_;

	print STDERR "=============== try_split_and_align ($chrom:$pos:$strand, $cigar, $breakpoint, $chrom2:$pos2:$strand2)\n" if $opt->{verbose} > 1;

	my $query;
	if ($strand eq '+') {
		return if ($breakpoint - $pos >= length($seq));  # soft-clip may be all adaptor
		$query = substr($seq, $breakpoint - $pos);
	} else {
		my $query_clipped = 0;
		if ($cigar =~ /^([0-9]+)S/) {
			$query_clipped = $1;
		}
		$query = rev_comp_seq(substr($seq, 0, $query_clipped));
	}

	my $target_start;
	my $target_end;
	if ($strand2 eq '+') {
		$target_start = $pos2 - $opt->{rev_expand_size};
		$target_end = $target_start + $opt->{max_fragment_size} + $opt->{rev_expand_size};
	} else {
		$target_end = $pos2;
		while ($cigar2 =~ /([0-9]+)[MD]/g) {
			$target_end += $1;
		}
		$target_end += $opt->{rev_expand_size};
		$target_start = $target_end - $opt->{max_fragment_size} - $opt->{rev_expand_size};
	}
	if ($target_start < 1) {
		$target_start = 1;
	}
	if ($target_end > length($genome->{$chrom2})) {
		$target_end = length($genome->{$chrom2});
	}
	my $target = substr($genome->{$chrom2}, $target_start - 1, $target_end - $target_start);
	my $target_strand = '+';
	if ($strand eq $strand2) {
		$target = rev_comp_seq($target);
		$target_strand = '-';
	}

	if ($opt->{verbose} > 1) {
		print STDERR "----------------------\n";
		print STDERR "target: '$target'\n";
		print STDERR "query : '$query'\n";
	}

	my $x = align($target, $query, $opt);
	if (defined $x) {
		my $breakpoint2;
		if ($target_strand eq '+') {
			$breakpoint2 = $target_start + $x;
		} else {
			$breakpoint2 = $target_end - $x;
		}
		print STDERR "align at: $x ($chrom2:$breakpoint2:$strand2, target_strand = '$target_strand')\n" if $opt->{verbose} > 1;

		if (compare_genomic_coord($chrom, $breakpoint, $strand, $chrom2, $breakpoint2, $strand2) <= 0) {
			print $output join("\t", $chrom, $breakpoint, $strand, $chrom2, $breakpoint2, $strand2, $id), "\n";
		} else {
			print $output join("\t", $chrom2, $breakpoint2, $strand2, $chrom, $breakpoint, $strand, $id), "\n";
		}
		return 1;
	} else {
		print STDERR "align failed\n" if $opt->{verbose} > 1;
		return 0;
	}
}

sub load_discordant_reads
{
	my $filename = shift;
	my $col_names = [ 'id', 'chrom', 'pos', 'strand', 'chrom2', 'pos2', 'strand2',
		'cigar', 'cigar2', 'seq', 'seq2', 'qual', 'qual2' ];
	my $data = load_tsv $filename, $col_names;
	return $data->{data};
}

sub process_paired_reads
{
	my ($output, $discord, $opt, $candidate_breakpoints_ref, $genome) = @_;

	for my $p (@{$discord}) {
		next if $p->{breakpoint} eq '-' and $p->{breakpoint2} eq '-';

		my $overlap = check_overlap($p->{seq}, $p->{strand}, $p->{seq2}, $p->{strand2}, $opt);
		if (defined $overlap) {
			if ($p->{breakpoint} ne '-') {
				my $seq = substr($p->{seq}, 0, $overlap);
				try_split_and_align $output, $genome, $p->{chrom}, $p->{pos}, $p->{strand}, $p->{breakpoint},
					$seq, $p->{cigar}, $p->{chrom2}, $p->{pos2}, $p->{strand2}, $p->{cigar2}, $p->{id}, $opt;
			} else {
				my $seq2 = substr($p->{seq2}, 0, $overlap);
				try_split_and_align $output, $genome, $p->{chrom2}, $p->{pos2}, $p->{strand2}, $p->{breakpoint2},
					$seq2, $p->{cigar2}, $p->{chrom}, $p->{pos}, $p->{strand}, $p->{cigar}, $p->{id}, $opt;
			}
		} else {
			if ($p->{breakpoint} ne '-') {
				my $ok = try_split_and_align $output, $genome, $p->{chrom}, $p->{pos}, $p->{strand}, $p->{breakpoint},
					$p->{seq}, $p->{cigar}, $p->{chrom2}, $p->{pos2}, $p->{strand2}, $p->{cigar2}, $p->{id}, $opt;
				next if $ok;
			}
			if ($p->{breakpoint2} ne '-') {
				try_split_and_align $output, $genome, $p->{chrom2}, $p->{pos2}, $p->{strand2}, $p->{breakpoint2},
					$p->{seq2}, $p->{cigar2}, $p->{chrom}, $p->{pos}, $p->{strand}, $p->{cigar}, $p->{id}, $opt;
			}
		}
	}
}

sub infer_breakpoint
{
	my ($strand, $cigar, $pos, $min_clip) = @_;
	if ($strand eq '+' and $cigar =~ /^((([0-9]+)[MID])+)([0-9]+)S$/) {
		my $cigar_without_clip = $1;
		my $clipped = $4;
		if ($clipped >= $min_clip) {
			my $breakpoint = $pos;
			while ($cigar_without_clip =~ /([0-9]+)[MD]/g) {
				$breakpoint += $1;
			}
			return $breakpoint;
		}
	} elsif ($strand eq '-' and $cigar =~ /^([0-9]+)S(([0-9]+)[MID])+$/) {
		my $clipped = $1;
		if ($clipped >= $min_clip) {
			return $pos;
		}
	}
	return '-';
}

sub do_identify
{
	my $opt = parse_opt_identify @_;

	my $discord = load_discordant_reads $opt->{input};
	for my $p (@{$discord}) {
		$p->{breakpoint} = infer_breakpoint $p->{strand}, $p->{cigar}, $p->{pos}, $opt->{min_clip};
		$p->{breakpoint2} = infer_breakpoint $p->{strand2}, $p->{cigar2}, $p->{pos2}, $opt->{min_clip};
	}
	my $breakpoint_supports = get_breakpoint_supports $discord;

	my %candidate_breakpoints = ();
	for my $key (sort { compare_genomic_coord2($a, $b) } keys %{$breakpoint_supports}) {
		my ($chrom, $pos, $strand) = split(':', $key);
		my $supports = $breakpoint_supports->{$key};
		my $supportingReads = 0;
		for my $pos (keys %{$breakpoint_supports->{$key}}) {
			$supportingReads += scalar @{$breakpoint_supports->{$key}->{$pos}};
		}

		next if scalar keys %{$supports} < $opt->{min_supp};
		$candidate_breakpoints{$chrom}->{$pos}->{$strand} = { supports => scalar keys %{$supports} };
	}

	my $genome = load_genome $opt->{genome}, $opt->{verbose};

	open my $output, ">", $opt->{output} or err "Failed to write '$opt->{output}'";
	print $output join("\t", 'chrom', 'pos', 'strand', 'chrom2', 'pos2', 'strand2', 'id'), "\n";
	process_paired_reads $output, $discord, $opt, \%candidate_breakpoints, $genome, $opt->{min_clip};
	close $output;

	return 0;
}

#==========================================================#
# command 'refine'

my $def_opt_refine = {
	verbose  => 0,
	input    => '',
	in_bam   => '',
	output   => '/dev/stdout',
	regions  => '',
	samtools => 'samtools'
};

sub print_usage_refine
{
	print "
Usage: fuseek refine [options] <breakpoints.txt> <in.bam> [fusions.txt]

Options:
   <breakpoints.txt>   input text file (generated by 'identify')
   <in.bam>            input bam file (the same source of 'collect')
   [fusions.txt]       output TAB-sep text file of fusions [$def_opt_refine->{output}]
   -b FILE             BED file of interest regions [null]
   -s FILE             command or full path of 'samtools' [$def_opt_refine->{samtools}]
   -v                  show verbose messages
   -h / --help         show this help message

";
	exit 1;
}

sub parse_opt_refine
{
	my %opt = %{$def_opt_refine};  # deep copy

	my @args = ();
	while (my $arg = shift) {
		if ($arg eq '-b') {
			err "Missing parameter for '$arg'!" unless @_;
			$opt{regions} = shift;
		} elsif ($arg eq '-s') {
			err "Missing parameter for '$arg'!" unless @_;
			$opt{samtools} = shift;
		} elsif ($arg eq '-v') {
			++$opt{verbose};
		} elsif ($arg eq '-h' or $arg eq '--help') {
			print_usage_refine;
		} else {
			err "Unknown option '$arg'!" if $arg =~ /^-/;
			err "Unexpected parameter '$arg'!" if scalar @args >= 3;
			push @args, $arg;
		}
	}
	print_usage_refine if scalar @args < 2;
	$opt{input} = shift @args;
	$opt{in_bam} = shift @args;
	$opt{output} = shift @args if @args;

	return \%opt;
}

sub do_refine
{
	my $opt = parse_opt_refine @_;

	my $breakpoints = load_tsv $opt->{input};

	my @results = ();
	my %supports = ();
	my %pos_list = ();
	for my $p (@{$breakpoints->{data}}) {
		my $key = join(':', map { $p->{$_} } ('chrom', 'pos', 'strand', 'chrom2', 'pos2', 'strand2'));
		if (not exists $supports{$key}) {
			push @results, $key;
		}
		$supports{$key}++;

		$pos_list{$p->{chrom}}->{$p->{pos}} = 0;
		$pos_list{$p->{chrom2}}->{$p->{pos2}} = 0;
	}

	my $temp_file = tmpnam();
	open my $file, ">", $temp_file or err "Can not open file '$temp_file' to write";
	for my $chrom (keys %pos_list) {
		for my $pos (keys %{$pos_list{$chrom}}) {
			print $file $chrom, "\t", $pos, "\n";
		}
	}
	close $file;

	my $samtools_options = "-F 0xF00";  # filter out: secondary (0x100), QC-failed (0x200), duplicated (0x400), supplementary (0x800)
	$samtools_options .= " -L $temp_file";
	my $command_line = "$opt->{samtools} view $samtools_options $opt->{in_bam}";
	open my $input, "-|", $command_line or err "Failed to view '$opt->{in_bam}'";
	while (my $line = <$input>) {
		chomp $line;
		my ($id, $flags, $chrom, $pos, $map_qual, $cigar,
			$chrom2, $pos2, $dist, $seq, $qual) = split("\t", $line);
		next unless exists $pos_list{$chrom};

		my $start = $pos;
		my $end = $start;
		while ($cigar =~ /^([0-9]+)[MD]/g) {
			$end += $1;
		}

		for $pos ($start .. ($end - 1)) {
			if (exists $pos_list{$chrom}->{$pos}) {
				$pos_list{$chrom}->{$pos}++;
			}
		}
	}
	close $input;

	unlink $temp_file;

	open my $output, '>', $opt->{output} or err "Failed to write '$opt->{output}'";
	print $output join("\t", 'chrom', 'pos', 'strand', 'chrom2', 'pos2', 'strand2', 'supports', 'depth1', 'depth2', 'freq1', 'freq2', 'freq'), "\n";
	for my $key (@results) {
		my ($chrom, $pos, $strand, $chrom2, $pos2, $strand2) = split(':', $key);
		my $count = $supports{$key};

		my $depth1 = 0;
		for my $i (0, 1, -1, 2, -2, 3, -3) {
			if (exists $pos_list{$chrom}->{$pos + $i}) {
				$depth1 = $pos_list{$chrom}->{$pos + $i};
				last;
			}
		}

		my $depth2 = 0;
		for my $i (0, 1, -1, 2, -2, 3, -3) {
			if (exists $pos_list{$chrom2}->{$pos2 + $i}) {
				$depth2 = $pos_list{$chrom2}->{$pos2 + $i};
				last;
			}
		}

		my $freq1;
		if ($depth1) {
			$freq1 = sprintf('%.2f', 100 * $count / $depth1);
		} else {
			$freq1 = '-';
		}

		my $freq2;
		if ($depth2) {
			$freq2 = sprintf('%.2f', 100 * $count / $depth2);
		} else {
			$freq2 = '-';
		}

		my $freq;
		if ($depth1 + $depth2 > 0) {
			$freq = sprintf('%.2f', 200 * $count / ($depth1 + $depth2));
		} else {
			$freq = '-';
		}

		print $output join("\t", $chrom, $pos, $strand, $chrom2, $pos2, $strand2,
			$count, $depth1, $depth2, $freq1, $freq2, $freq), "\n";
	}
	close $output;

	return 0;
}

#==========================================================#
# command 'sort'

my $def_opt_sort = {
	verbose => 0,
	input   => '',
	output  => '/dev/stdout',
	reverse => 0,
};

sub print_usage_sort
{
	print "
Usage: fuseek sort [options] <fusions.txt> [output.txt]

Options:
   <fusions.txt>   input TAB-sep file of fusions
   [output.txt]    output text file of sorted fusions
   -r              sort reversely
   -v              show verbose messages
   -h / --help     show this help message

";
	exit 1;
}

sub parse_opt_sort
{
	my %opt = %{$def_opt_sort};  # deep copy

	my @args = ();
	while (my $arg = shift) {
		if ($arg eq '-r') {
			$opt{reverse} = 1;
		} elsif ($arg eq '-v') {
			++$opt{verbose};
		} elsif ($arg eq '-h' or $arg eq '--help') {
			print_usage_sort;
		} else {
			err "Unknown option '$arg'!" if $arg =~ /^-/;
			err "Unexpected parameter '$arg'!" if scalar @args >= 2;
			push @args, $arg;
		}
	}
	print_usage_sort if scalar @args < 1;
	$opt{input} = shift @args;
	$opt{output} = shift @args if @args;

	return \%opt;
}

sub do_sort
{
	my $opt = parse_opt_sort @_;

	my $fusions = load_tsv $opt->{input};

	open my $output, '>', $opt->{output} or err "Failed to write '$opt->{output}'";
	my $reverse = ($opt->{reverse} ? -1 : 1);
	print $output join("\t", @{$fusions->{names}}), "\n";
	for my $item (sort { compare_fusion($a, $b) * $reverse } @{$fusions->{data}}) {
		print $output join("\t", map { $item->{$_} } @{$fusions->{names}}), "\n";
	}
	close $output;

	return 0;
}

#==========================================================#
# command 'annotate'

my $def_opt_annotate = {
	verbose      => 0,
	input        => '',
	output       => '/dev/stdout',
	gene_anno_db => '',
};

sub print_usage_annotate
{
	print "
Usage: fuseek annotate [options] <genes.gz> <fusions.txt> [annotated.txt]

Options:
   <genes.gz>        gene annotation file (such as 'refGene.gz' downloaded from UCSC)
   <fusions.txt>     input text file (generated by 'refine')
   [annotated.txt]   output TAB-sep text file of annotated fusions [$def_opt_annotate->{output}]
   -v                show verbose messages
   -h / --help       show this help message

";
	exit 1;
}

sub parse_opt_annotate
{
	my %opt = %{$def_opt_annotate};  # deep copy

	my @args = ();
	while (my $arg = shift) {
		if ($arg eq '-v') {
			++$opt{verbose};
		} elsif ($arg eq '-h' or $arg eq '--help') {
			print_usage_annotate;
		} else {
			err "Unknown option '$arg'!" if $arg =~ /^-/;
			err "Unexpected parameter '$arg'!" if scalar @args >= 3;
			push @args, $arg;
		}
	}
	print_usage_annotate if scalar @args < 2;
	$opt{gene_anno_db} = shift @args;
	$opt{input} = shift @args;
	$opt{output} = shift @args if @args;

	return \%opt;
}

sub compare_fusion
{
	my ($a, $b) = @_;
	my $res = compare_genomic_coord(
		$a->{chrom}, $a->{pos}, $a->{strand},
		$b->{chrom}, $b->{pos}, $b->{strand});
	if ($res == 0) {
		$res = compare_genomic_coord(
			$a->{chrom2}, $a->{pos2}, $a->{strand2},
			$b->{chrom2}, $b->{pos2}, $b->{strand2});
	}
	return $res;
}

sub annotate_breakpoint
{
	my ($genes, $chrom, $pos, $strand) = @_;
	my $current = { chrom => $chrom, pos => $pos };
	my $index = binsearch { compare_pos_and_range($a, $b) } $current, @{$genes};
	my @results = ();
	if (defined $index) {
		for (; $index < scalar @{$genes}; ++$index) {
			my $item = $genes->[$index];
			last if compare_pos_and_range $current, $item;

			my $last_exon = 0;
			my $tx_pos = 0;
			my $tx_offset = 0;
			if ($item->{strand} eq '+') {
				for (my $i = 0; $i < $item->{exonCount}; ++$i) {
					if ($pos < $item->{exonStarts}->[$i]) {
						if ($strand eq '+') {
							$last_exon = $i;
						} else {
							$last_exon = $i + 1;
						}
						if ($i == 0) {
							$tx_offset = $pos - $item->{exonStarts}->[$i];
						} else {
							$tx_offset = $pos - $item->{exonEnds}->[$i - 1];
						}
						last;
					} elsif ($pos < $item->{exonEnds}->[$i]) {
						$last_exon = $i + 1;
						$tx_pos += $pos - $item->{exonStarts}->[$i];
						last;
					}
					$tx_pos += $item->{exonEnds}->[$i] - $item->{exonStarts}->[$i];
				}
			} else {
				for (my $i = 0; $i < $item->{exonCount}; ++$i) {
					my $j = $item->{exonCount} - $i - 1;
					if ($pos >= $item->{exonEnds}->[$j]) {
						if ($strand eq '-') {
							$last_exon = $i;
						} else {
							$last_exon = $i + 1;
						}
						if ($i == 0) {
							$tx_offset = $item->{exonEnds}->[$j] - $pos;
						} else {
							$tx_offset = $item->{exonStarts}->[$j + 1] - $pos;
						}
						last;
					} elsif ($pos >= $item->{exonStarts}->[$j]) {
						$last_exon = $i + 1;
						$tx_pos += $item->{exonEnds} - $pos;
						last;
					}
					$tx_pos += $item->{exonEnds}->[$i] - $item->{exonStarts}->[$i];
				}
			}
			push @results, { gene => $item->{gene}, transcript => $item->{transcript}, strand => $item->{strand},
				exon => $last_exon, tx_pos => $tx_pos, tx_offset => $tx_offset, tx_size => $item->{tx_size} };
		}
	}
	return \@results;
}

sub parse_pos
{
	my ($sub, $strand) = @_;
	my $text = $sub->{tx_pos};
	if ($sub->{tx_offset} > 0) {
		$text .= '+' . $sub->{tx_offset};
	} elsif ($sub->{tx_offset} < 0) {
		$text .= '-' . $sub->{tx_offset};
	}
	if ($sub->{strand} eq $strand) {
		$text = '1_' . $text;
	} else {
		$text .= '_' . $sub->{tx_size};
	}
	return 'r.' . $text;
}

sub join_gene
{
	my $anno = shift;
	my $n = scalar @{$anno};
	if ($n == 0) {
		return "";
	} elsif ($n == 1) {
		return $anno->[0]->{gene};
	} else {
		my $gene = $anno->[0]->{gene};
		my $any_diff = 0;
		for my $i (1 .. ($n - 1)) {
			if ($gene ne $anno->[$i]->{gene}) {
				$any_diff = 1;
				last;
			}
		}
		if ($any_diff) {
			return join(";", map { $_->{gene} } @{$anno});
		} else {
			return $gene;
		}
	}
}

sub do_annotate
{
	my $opt = parse_opt_annotate @_;

	my $fusions = load_tsv $opt->{input};
	my $genes = load_genes $opt->{gene_anno_db};

	open my $output, '>', $opt->{output} or err "Failed to write '$opt->{output}'";

	my @nameSet1 = ('chrom', 'pos', 'strand', 'chrom2', 'pos2', 'strand2');
	my %nameSet1 = map { $_ => 1 } @nameSet1;
	my @nameSet2 = grep { ! exists $nameSet1{$_} } @{$fusions->{names}};
	print $output join("\t", @nameSet1, 'gene', 'transcript', 'exon', 'anno', 'gene2', 'transcript2', 'exon2', 'anno2', @nameSet2), "\n";
	for my $item (@{$fusions->{data}}) {

		print $output join("\t", $item->{chrom}, $item->{pos}, $item->{strand},
			$item->{chrom2}, $item->{pos2}, $item->{strand2}), "\t";

		my $anno1 = annotate_breakpoint $genes, $item->{chrom}, $item->{pos}, $item->{strand};
		if (@{$anno1}) {
			print $output join("\t",
				join_gene($anno1),
				join(";", map { $_->{transcript} } @{$anno1}),
				join(";", map { $_->{exon} } @{$anno1}),
				join(";", map { parse_pos $_, $item->{strand} } @{$anno1}));
		} else {
			print $output join("\t", ( "-" ) x 4);
		}

		print $output "\t";

		my $anno2 = annotate_breakpoint $genes, $item->{chrom2}, $item->{pos2}, $item->{strand2};
		if (@{$anno2}) {
			print $output join("\t",
				join_gene($anno2),
				join(";", map { $_->{transcript} } @{$anno2}),
				join(";", map { $_->{exon} } @{$anno2}),
				join(";", map { parse_pos $_, $item->{strand} } @{$anno2}));
		} else {
			print $output join("\t", ( "-" ) x 4);
		}

		print $output "\t", join("\t", map { $item->{$_} } @nameSet2), "\n";
	}
	close $output;

	return 0;
}

#==========================================================#
# command 'filter'

my $def_opt_filter = {
	verbose => 0,
	input   => '',
	output  => '/dev/stdout'
};

sub print_usage_filter
{
	print "
Usage: fuseek filter [options] <fusions.txt> [output.txt]

Options:
   <fusions.txt>   input TAB-sep filter of fusions
   [output.txt]    output text file of filtered fusions
   -v              show verbose messages
   -h / --help     show this help message

";
	exit 1;
}

sub parse_opt_filter
{
	my %opt = %{$def_opt_filter};  # deep copy

	my @args = ();
	while (my $arg = shift) {
		if ($arg eq '-v') {
			++$opt{verbose};
		} elsif ($arg eq '-h' or $arg eq '--help') {
			print_usage_filter;
		} else {
			err "Unknown option '$arg'!" if $arg =~ /^-/;
			err "Unexpected parameter '$arg'!" if scalar @args >= 2;
			push @args, $arg;
		}
	}
	print_usage_filter if scalar @args < 1;
	$opt{input} = shift @args;
	$opt{output} = shift @args if @args;

	return \%opt;
}

sub do_filter
{
	my $opt = parse_opt_filter @_;

	my $fusions = load_tsv $opt->{input};

	open my $output, '>', $opt->{output} or err "Failed to write '$opt->{output}'";
	print $output join("\t", @{$fusions->{names}}), "\n";
	for my $item (@{$fusions->{data}}) {
		next if $item->{gene} eq '-';
		next if $item->{gene2} eq '-';
		next if $item->{gene} eq $item->{gene2};
		next if $item->{supports} <= 1;
		print $output join("\t", map { $item->{$_} } @{$fusions->{names}}), "\n";
	}
	close $output;

	return 0;
}

#==========================================================#
# command 'run'

my $def_opt_run = {
	verbose    => 0,
	input_bam  => '',
	out_prefix => '',
	regions    => '',
	samtools   => 'samtools',
};

sub print_usage_run
{
	print "
Usage: fuseek run [options] <ref.fa> <genes.gz> <in.bam> <out-prefix>

Options:
   <ref.fa>        reference genome in FASTA format
   <genes.gz>      gene annotation file (such as 'refGene.gz' downloaded from UCSC)
   <in.bam>        input (sorted) bam (generated by aligner like 'bwa')
   <out-prefix>    prefix (may contains directory name) of output files
   -b FILE         BED file of interest regions [null]
   -s FILE         command or full path of 'samtools' [$def_opt_run->{samtools}]
   -v              show verbose messages
   -h / --help     show this help message

";
	exit 1;
}

sub parse_opt_run
{
	my %opt = %{$def_opt_run};  # deep copy

	my @args = ();
	while (my $arg = shift) {
		if ($arg eq '-b') {
			err "Missing parameter for '$arg'!" unless @_;
			$opt{regions} = shift;
		} elsif ($arg eq '-s') {
			err "Missing parameter for '$arg'!" unless @_;
			$opt{samtools} = shift;
		} elsif ($arg eq '-v') {
			++$opt{verbose};
		} elsif ($arg eq '-h' or $arg eq '--help') {
			print_usage_run;
		} else {
			err "Unknown option '$arg'!" if $arg =~ /^-/;
			err "Unexpected parameter '$arg'!" if scalar @args >= 5;
			push @args, $arg;
		}
	}
	print_usage_run if scalar @args < 4;
	$opt{genome} = shift @args;
	$opt{gene_anno_db} = shift @args;
	$opt{input_bam} = shift @args;
	$opt{out_prefix} = shift @args;
	$opt{regions} = shift @args if @args;

	return \%opt;
}

sub do_run
{
	my $opt = parse_opt_run @_;

	my @args = ();
	push @args, ('-b', $opt->{regions}) if $opt->{regions};
	push @args, ('-v') x $opt->{verbose} if $opt->{verbose};
	push @args, ('-s', $opt->{samtools}) if $opt->{samtools} ne 'samtools';

	prep_dir $opt->{out_prefix};

	my $file0 = $opt->{input_bam};

	my $file1 = "$opt->{out_prefix}.1-discord.txt";
	die unless -e $file0;
	if (not -e $file1 or -M $file0 < -M $file1) {
		print STDERR "Generating '$file1'...\n";
		my $ret = do_collect $file0, $file1, @args;
		return $ret if $ret;
	}

	my $file2 = "$opt->{out_prefix}.2-breakpoints.txt";
	die unless -e $file1;
	if (not -e $file2 or -M $file1 < -M $file2) {
		print STDERR "Generating '$file2'...\n";
		my $ret = do_identify $opt->{genome}, $file1, $file2;
		return $ret if $ret;
	}

	my $file3 = "$opt->{out_prefix}.3-fusions.txt";
	die unless -e $file2;
	if (not -e $file3 or -M $file2 < -M $file3) {
		print STDERR "Generating '$file3'...\n";
		my $ret = do_refine $file2, $opt->{input_bam}, $file3, @args;
		return $ret if $ret;
	}

	my $file4 = "$opt->{out_prefix}.4-fusions.sorted.txt";
	die unless -e $file3;
	if (not -e $file4 or -M $file3 < -M $file4) {
		print STDERR "Generating '$file4'...\n";
		my $ret = do_sort $file3, $file4;
		return $ret if $ret;
	}

	my $file5 = "$opt->{out_prefix}.5-fusions.sorted.annotated.txt";
	die unless -e $file4;
	if (not -e $file5 or -M $file4 < -M $file5) {
		print STDERR "Generating '$file5'...\n";
		my $ret = do_annotate $opt->{gene_anno_db}, $file4, $file5;
		return $ret if $ret;
	}

	my $file6 = "$opt->{out_prefix}.6-fusions.sorted.annotated.filtered.txt";
	die unless -e $file5;
	if (not -e $file6 or -M $file5 < -M $file6) {
		print STDERR "Generating '$file6'...\n";
		my $ret = do_filter $file5, $file6;
		return $ret if $ret;
	}

	print STDERR "Done.\n";
	return 0;
}

#==========================================================#
# main procedure

my $git_hash = '$Id$';
my $version_suffix = "";
if ($git_hash =~ /Id: (.*) /) {
	$version_suffix = ' (' . substr($1, 0, 7) . ')';
}
my $version = "0.0.1$version_suffix";

#----------------------------------------------------------#

my %commands = (
	collect  => \&do_collect,
	identify => \&do_identify,
	refine   => \&do_refine,
	sort     => \&do_sort,
	annotate => \&do_annotate,
	filter   => \&do_filter,
	run      => \&do_run,
	version  => sub { print $version, "\n"; }
);

sub print_usage
{
	print "
Program: fuseek (FUsion SEEKer)
Version: $version

Usage:   fuseek <command> [options]

Commands:
   run        batch run (collect, identify, refine, annotate)
   collect    collect discordant reads from BAM file
   identify   identify fusions from discordant reads
   refine     refine breakpoints of fusions
   sort       sort fusions by genomic coordinates
   annotate   annotate fusions
   filter     filter fusions

";
	exit 1;
}

print_usage unless @ARGV;

my $cmd = shift;
err "Unknown command '$cmd'!" unless exists $commands{$cmd};
exit $commands{$cmd}->(@ARGV);
