#!/usr/bin/env perl
use strict;
use warnings 'all';
use List::BinarySearch qw( binsearch );

#==========================================================#
# common variables

my @chrom_set = map { "chr$_" } (1..22, "X", "Y");  # only consider: chr1..22, X & Y
my %chrom_set = map { $chrom_set[$_] => $_ } (0 .. $#chrom_set);

my %strand_set = ( '+' => 0, '-' => 1 );

#==========================================================#
# useful functions

sub err
{
	print STDERR "Error: ", @_, "\n";
	exit 1;
}

sub ensure_directory
{
	my @a = split('/', shift);
	for my $i (0 .. $#a) {
		my $d = join("/", @a[0 .. $i]);
		if (not -d $d) {
			print STDERR "Create directory '$d'\n";
			mkdir $d or die;
		}
	}
}

sub compare_genomic_coord
{
	my ($p, $p2) = @_;
	my $res = $chrom_set{$p->{chrom}} <=> $chrom_set{$p2->{chrom}};
	if ($res == 0) {
		$res = $p->{pos} <=> $p2->{pos};
		if ($res == 0) {
			$res = $strand_set{$p->{strand}} <=> $strand_set{$p2->{strand}};
		}
	}
	return $res;
}

sub compare_genomic_range
{
	my ($p, $p2) = @_;
	my $res = $chrom_set{$p->{chrom}} <=> $chrom_set{$p2->{chrom}};
	if ($res == 0) {
		$res = $p->{start} <=> $p2->{start};
		if ($res == 0) {
			$res = $p->{end} <=> $p2->{end};
			if ($res == 0) {
				$res = $strand_set{$p->{strand}} <=> $strand_set{$p2->{strand}};
			}
		}
	}
	return $res;
}

sub compare_genomic_coord2
{
	my ($a, $b) = @_;
	my ($chrom, $pos, $strand) = split(':', $a, 3);
	my ($chrom2, $pos2, $strand2) = split(':', $b, 3);

	my $res = $chrom_set{$chrom} <=> $chrom_set{$chrom2};
	if ($res == 0) {
		$res = $pos <=> $pos2;
		if ($res == 0) {
			$res = $strand_set{$strand} <=> $strand_set{$strand2};
		}
	}
	return $res;
}

sub compare_pos_and_range
{
	my ($a, $b) = @_;
	my $res = $chrom_set{$a->{chrom}} <=> $chrom_set{$b->{chrom}};
	if ($res == 0) {
		if ($a->{pos} < $b->{start}) {
			$res = -1;
		} elsif ($a->{pos} >= $b->{end}) {
			$res = 1;
		}
	}
	return $res;
}

sub rev_comp_seq
{
	my $seq = shift;
	$seq =~ tr/ACGTacgt/TGCAtgca/;
	return reverse $seq;
}

sub load_genome
{
	my $filename = shift;

	my %genome = ();

	print STDERR "Loading genome:";
	open my $file, "<", $filename or die "Failed to read '$filename'";
	my $name;
	while (my $line = <$file>) {
		chomp $line;
		if ($line =~ /^>/) {
			$name = substr($line, 1);
			$name =~ s/\s.*$//;
			$name = '' unless exists $chrom_set{$name};
			print STDERR " $name" if $name;
		} elsif ($name ne '') {
			$genome{$name} .= uc $line;
		}
	}
	close $file;
	print STDERR " done.\n";

	return \%genome;
}

#==========================================================#
# 'collect'

my $def_opt_collect = {
	verbose  => 0,
	input    => '',
	output   => '/dev/stdout',
	max_dist => 1000,
	min_clip => 5,
	samtools => 'samtools'
};

sub print_usage_collect
{
	print "
Usage: fuseek collect [options] <in.bam>

Options:
   -h / --help      show this help message
   -v / --verbose   show verbose messages
   -o FILE          output to file rather than stdout [$def_opt_collect->{output}]
   -d INT           maximum distance of concordant reads [$def_opt_collect->{max_dist}]
   -m INT           minimum size of soft clipping [$def_opt_collect->{min_clip}]
   -s FILE          command or full path of 'samtools' [$def_opt_collect->{samtools}]
   <in.bam>         input (sorted) bam (generated by aligner like 'bwa')

";
	exit 1;
}

sub parse_opt_collect
{
	my %opt = %{$def_opt_collect};  # deep copy

	my @args = ();
	while (my $arg = shift) {
		if ($arg eq '-h' or $arg eq '--help') {
			print_usage_collect
		} elsif ($arg eq '-v' or $arg eq '--verbose') {
			++$opt{verbose};
		} elsif ($arg eq '-o') {
			err "Missing parameter for '$arg'!" unless @_;
			$opt{output} = shift;
		} elsif ($arg eq '-d') {
			err "Missing parameter for '$arg'!" unless @_;
			$opt{max_dist} = shift;
		} elsif ($arg eq '-m') {
			err "Missing parameter for '$arg'!" unless @_;
			$opt{min_clip} = shift;
		} elsif ($arg eq '-s') {
			err "Missing parameter for '$arg'!" unless @_;
			$opt{samtools} = shift;
		} else {
			err "Unknown option '$arg'!" if $arg =~ /^-/;
			err "Unexpected parameter '$arg'!" if $#args == 0;
			push @args, $arg;
		}
	}
	print_usage_collect unless $#args == 0;
	($opt{input}) = @args;

	return \%opt;
}

sub do_collect
{
	my $opt = parse_opt_collect @_;

	my $samtools_options = "-F 0x70C";  # filter out: unmapped, secondary, QC-failed, duplicated
	my $command_line = "$opt->{samtools} view $samtools_options $opt->{input}";

	open my $file, "-|", $command_line or die "Failed to view '$opt->{input}'";
	open my $output, ">", $opt->{output} or die "Failed to write '$opt->{output}'";

	my @output_cols = ('chrom', 'pos', 'strand', 'breakpoint', 'cigar',
		'chrom2', 'pos2', 'strand2', 'breakpoint2', 'cigar2',
		'id', 'seq', 'seq2', 'qual', 'qual2');
	print $output join("\t", @output_cols), "\n";

	my %data = ();
	my @results = ();
	while (my $line = <$file>) {
		chomp $line;
		my ($id, $flags, $chrom, $pos, $map_qual, $cigar,
			$chrom2, $pos2, $dist, $seq, $qual) = split("\t", $line);

		next if $map_qual == 0;                                     # skip multiple-mapped
		next if $chrom2 eq '=' and abs($dist) <= $opt->{max_dist};  # skip concordant
		$chrom2 = $chrom if $chrom2 eq '=';                         # update peer chrom name
		next if not exists $chrom_set{$chrom};                      # skip super-contigs
		next if not exists $chrom_set{$chrom2};                     # skip super-contigs (peer)

		my $strand = (($flags & 0x10) ? '-' : '+');
		my $strand2 = (($flags & 0x20) ? '-' : '+');

		my $breakpoint = '-';
		if ($strand eq '+' and $cigar =~ /^((([0-9]+)[MID])+)([0-9]+)S$/) {
			if ($4 >= $opt->{min_clip}) {
				my $match_text = $1;
				$breakpoint = $pos;
				while ($match_text =~ /([0-9]+)[MD]/g) {
					$breakpoint += $1;
				}
			}
		} elsif ($strand eq '-' and $cigar =~ /^([0-9]+)S(([0-9]+)[MID])+$/) {
			if ($1 < $opt->{min_clip}) {
				$breakpoint = $pos + $1;
			}
		}

		my $p = {
			chrom => $chrom, pos => $pos, strand => $strand, breakpoint => $breakpoint, cigar => $cigar,
			chrom2 => $chrom2, pos2 => $pos2, strand2 => $strand2,
			id => $id, seq => $seq, qual => $qual
		};
		if (not exists $data{$id}) {
			$data{$id} = $p;
		} else {
			my $q = $data{$id};
			die "Unmatched pair info for read '$id' in '$opt->{input}'" unless
				$p->{chrom} eq $q->{chrom2} and $p->{pos} == $q->{pos2} and $p->{strand} eq $q->{strand2} and
				$p->{chrom2} eq $q->{chrom} and $p->{pos2} == $q->{pos} and $p->{strand2} eq $q->{strand};

			if (compare_genomic_coord($p, $q) <= 0) {
				push @results, {
					chrom => $p->{chrom}, pos => $p->{pos}, strand => $p->{strand}, breakpoint => $p->{breakpoint}, cigar => $p->{cigar},
					chrom2 => $q->{chrom}, pos2 => $q->{pos}, strand2 => $q->{strand}, breakpoint2 => $q->{breakpoint}, cigar2 => $q->{cigar},
					id => $id, seq => $p->{seq}, seq2 => $q->{seq}, qual => $p->{qual}, qual2 => $q->{qual}
				};
			} else {
				push @results, {
					chrom => $q->{chrom}, pos => $q->{pos}, strand => $q->{strand}, breakpoint => $q->{breakpoint}, cigar => $q->{cigar},
					chrom2 => $p->{chrom}, pos2 => $p->{pos}, strand2 => $p->{strand}, breakpoint2 => $p->{breakpoint}, cigar2 => $p->{cigar},
					id => $id, seq => $q->{seq}, seq2 => $p->{seq}, qual => $q->{qual}, qual2 => $p->{qual}
				};
			}
		}
	}
	close $file;

	for my $item (sort { compare_genomic_coord($a, $b) } @results) {
		print $output join("\t", map { $item->{$_} } @output_cols), "\n";
	}
	close $output;
}

#==========================================================#
# 'identify'

my $def_opt_identify = {
	verbose           => 0,
	input             => '',
	output            => '/dev/stdout',
	genome_fasta      => '',
	ref_gene          => '',

	seed_size         => 8,
	max_fragment_size => 500,
	max_indel_size    => 3,
	match_for_indel   => 5
};

sub print_usage_identify
{
	print "
Usage: fuseek identify [options] <discord.txt> <ref.fa>

Options:
   -h / --help      show this help message
   -v / --verbose   show verbose messages
   -o FILE          output to file rather than stdout [$def_opt_identify->{output}]
   -r FILE          path of UCSC ref-gene annotation file
   <discord.txt>    input text file (generated by 'collect')

";
	exit 1;
}

sub parse_opt_identify
{
	my %opt = %{$def_opt_identify};  # deep copy

	my @args = ();
	while (my $arg = shift) {
		if ($arg eq '-h' or $arg eq '--help') {
			print_usage_identify
		} elsif ($arg eq '-v' or $arg eq '--verbose') {
			++$opt{verbose};
		} elsif ($arg eq '-o') {
			err "Missing parameter for '$arg'!" unless @_;
			$opt{output} = shift;
		} elsif ($arg eq '-r') {
			err "Missing parameter for '$arg'!" unless @_;
			$opt{ref_gene} = shift;
		} else {
			err "Unknown option '$arg'!" if $arg =~ /^-/;
			err "Unexpected parameter '$arg'!" if $#args == 1;
			push @args, $arg;
		}
	}
	print_usage_identify unless $#args == 1;
	($opt{input}, $opt{genome_fasta}) = @args;

	return \%opt;
}

sub do_identify
{
	my $opt = parse_opt_identify @_;

	open my $file, "<", $opt->{input} or die "Failed to read '$opt->{input}'";
	open my $output, ">", $opt->{output} or die "Failed to write '$opt->{output}'";

	my @input_cols = ('chrom', 'pos', 'strand', 'breakpoint', 'cigar',
		'chrom2', 'pos2', 'strand2', 'breakpoint2', 'cigar2',
		'id', 'seq', 'seq2', 'qual', 'qual2');

	my $line_no = 0;
	my %breakpoints0 = ();
	while (my $line = <$file>) {
		chomp $line;

		if (++$line_no == 1) {
			die "Unexpected columns in '$opt->{input}'" if $line ne join("\t", @input_cols);
			next;
		}
		my @s = split("\t", $line);
		die "Unexpected column count at line $line_no in '$opt->{input}'" if $#s != $#input_cols;

		my %f = map { $input_cols[$_] => $s[$_] } (0 .. $#s);

		if ($f{breakpoint} ne '-') {
			my $key = join(':', $f{chrom}, $f{breakpoint}, $f{strand});
			push @{$breakpoints0{$key}->{$f{pos}}}, { id => $f{id}, end => 1, seq => $f{seq}, qual => $f{qual} };
		}
		if ($f{breakpoint2} ne '-') {
			my $key = join(':', $f{chrom2}, $f{breakpoint2}, $f{strand2});
			push @{$breakpoints0{$key}->{$f{pos2}}}, { id => $f{id2}, end => 2, seq => $f{seq2}, qual => $f{qual2} };
		}
	}
	close $file;

	my @refGene = ();
	if ($opt->{ref_gene} ne '') {
		open my $file, "-|", "zcat $opt->{ref_gene}" or die "Cannot read file '$opt->{ref_gene}'";
		<$file>; # skip first line
		@refGene = sort {
				compare_genomic_range($a, $b)
			} grep {
				exists $chrom_set{$_->{chrom}}
			} map {
				my @s = split "\t";
				{
					chrom => $s[2], start => $s[4], end => $s[5], strand => $s[3],
					gene => $s[12], transcript => $s[1]
				}
			} <$file>;
		close $file;
	}

	my %candidate_breakpoints = ();

	for my $key (sort{ compare_genomic_coord2($a, $b) }keys %breakpoints0) {
		my ($chrom, $pos, $strand) = split(':', $key);
		my $supports = $breakpoints0{$key};
		my $supportingReads = 0;
		for my $pos (keys %{$breakpoints0{$key}}) {
			$supportingReads += scalar @{$breakpoints0{$key}->{$pos}};
		}

		my $gene = '-';
		my $transcript = '-';
		if (@refGene) {
			my $current = { chrom => $chrom, pos => $pos };
			my $index = binsearch { compare_pos_and_range($a, $b) } $current, @refGene;
			if (defined $index) {
				my %genes = ();
				for (;;) {
					$genes{$refGene[$index]->{gene}}->{$refGene[$index]->{transcript}}++;
					last if ++$index > $#refGene;
					last if compare_pos_and_range($current, $refGene[$index]);
				}
				if (%genes) {
					$gene = join(";", sort keys %genes);
					$transcript = join(";", map{ join(",", sort keys %{$genes{$_}}) } sort keys %genes);
				}
			}
		}

		next if scalar keys %{$supports} < 2;
		next if $opt->{ref_gene} ne '' and $gene eq '-';

		$candidate_breakpoints{$chrom}->{$pos}->{$strand} = 1;
	}

	sub match
	{
		my ($a, $i, $b, $j, $n) = @_;

		return 0 if $i + $n > scalar @{$a};
		return 0 if $j + $n > scalar @{$b};

		for my $k (0 .. ($n - 1)) {
			return 0 if $a->[$i + $k] ne $b->[$j + $k];
		}
		return 1;
	}

	sub extend
	{
		my ($target, $query, $opt) = @_;

		my @t = split("", $target);
		my @q = split("", $query);

		my $max_allowed_mismatch = int(scalar(@q) * 0.1);  # allow 10% mismatch
		my $max_allowed_indel = int(scalar(@q) * 0.05);    # allow 5% indel

		my $mismatch = 0;
		my $indel = 0;
		my $i = 0;
		my $j = 0;
		while ($i <= $#t and $j <= $#q) {
			if ($t[$i] eq $q[$j]) {
				++$i; ++$j;
			} else {
				++$mismatch;
				return 0 if $mismatch > $max_allowed_mismatch;
				my $ok = 0;
				if ($indel < $max_allowed_indel) {
					for my $try_indel (1 .. $opt->{max_indel_size}) {
						if (match(\@t, $i + $try_indel, \@q, $j, $opt->{match_for_indel})) {
							++$indel;
							$i += $try_indel + $opt->{match_for_indel};
							$j += $opt->{match_for_indel};
							$ok = 1;
							last;
						}
						if (match(\@t, $i, \@q, $j + $try_indel, $opt->{match_for_indel})) {
							++$indel;
							$i += $opt->{match_for_indel};
							$j += $try_indel + $opt->{match_for_indel};
							$ok = 1;
							last;
						}
					}
				}
				if (!$ok) {
					++$i; ++$j;
				}
			}
		}
		return ($j >= $#q);
	}

	sub align
	{
		my ($target, $query, $opt) = @_;

		my $target_size = length($target);
		my $query_size = length($query);

		my $seed = $query;  # first n bases that should match exactly (to determine breakpoint)
		my $rest = '';
		if ($query_size > $opt->{seed_size}) {
			$seed = substr($query, 0, $opt->{seed_size});
			$rest = substr($query, $opt->{seed_size});
		}

		for my $pos (0 .. ($target_size - $query_size)) {
			if (substr($target, $pos, $opt->{seed_size}) eq $seed) {  # exact-matched
				if ($rest eq '' or extend(substr($target, $pos + $opt->{seed_size}), $rest, $opt)) {
					return $pos;
				}
			}
		}
		return undef;
	}

	sub check_overlap
	{
		my ($seq, $strand, $seq2, $strand2, $opt) = @_;

		my $seq_len = length($seq);
		die if $seq_len != length($seq2);

		# convert back to original as in .fastq
		$seq = rev_comp_seq($seq) if $strand eq '-';
		$seq2 = rev_comp_seq($seq2) if $strand2 eq '-';

		my $rseq2 = rev_comp_seq($seq2);  # rev-comp to compare

		for (my $len = $seq_len; $len >= 10; --$len) {
			my $x = align(substr($seq, 0, $len), substr($rseq2, $seq_len - $len, $len), $opt);
			if (defined $x) {
				return $len;
			}
		}
		return undef;
	}

	my %breakpoints = ();

	sub add_breakpoint
	{
		my ($breakpoints_ref, $chrom, $pos, $strand, $chrom2, $pos2, $strand2, $id) = @_;

		my $key = join(':', $chrom, $pos, $strand);
		my $key2 = join(':', $chrom2, $pos2, $strand2);
		if (compare_genomic_coord2($key, $key2) <= 0) {
			($key, $key2) = ($key2, $key);
		}
		$breakpoints_ref->{$key}->{$key2}->{$id}++;
	}

	sub try_split_and_align
	{
		my ($genome, $chrom, $pos, $strand, $breakpoint, $seq, $cigar, $chrom2, $pos2, $strand2, $seq2, $id, $opt, $breakpoints_ref) = @_;

		my $o = check_overlap($seq, $strand, $seq2, $strand2, $opt);
		if (defined $o) {
			$seq = substr($seq, 0, $o);
		}

		my $query;
		if ($strand eq '+') {
			my $query_clipped = 0;
			if ($cigar =~ /([0-9]+)S$/) {
				$query_clipped += $1;
			}
			$query = substr($seq, length($seq) - $query_clipped);
		} else {
			my $query_clipped = 0;
			if ($cigar =~ /^([0-9]+)S/) {
				$query_clipped += $1;
			}
			$query = rev_comp_seq(substr($seq, 0, $query_clipped));
		}

		my $target;
		if ($strand2 eq '+') {
			$target = substr($genome->{$chrom2}, $pos2, $opt->{max_fragment_size});
		} else {
			$target = substr($genome->{$chrom2}, $pos2 + length($seq2) - $opt->{max_fragment_size}, $opt->{max_fragment_size});
		}
		if ($strand eq $strand2) {
			$target = rev_comp_seq($target);
		}

		my $x = align($target, $query, $opt);
		if (defined $x) {
			my $breakpoint2;
			if ($strand2 eq '+') {
				$breakpoint2 = $pos2 + $x;
			} else {
				$breakpoint2 = $pos2 - $x;
			}
			add_breakpoint $breakpoints_ref, $chrom, $breakpoint, $strand, $chrom2, $breakpoint2, $strand2, $id;
		}
	}

	sub process_paired_reads
	{
		my ($filename, $opt, $breakpoints_ref, $candidate_breakpoints_ref, $genome) = @_;

		open my $file, "<", $filename or die "Failed to read '$filename'";
		<$file>;  # skip first line
		while (my $line = <$file>) {
			chomp $line;
			my ($chrom, $pos, $strand, $breakpoint, $cigar,
				$chrom2, $pos2, $strand2, $breakpoint2, $cigar2,
				$id, $seq, $seq2, $qual, $qual2) = split("\t", $line);

			if ($breakpoint ne '-' and exists $candidate_breakpoints_ref->{$chrom}->{$breakpoint}->{$strand}) {
				try_split_and_align $genome, $chrom, $pos, $strand, $breakpoint, $seq, $cigar, $chrom2, $pos2, $strand2, $seq2, $id, $opt, $breakpoints_ref;
			}
			if ($breakpoint2 ne '-' and exists $candidate_breakpoints_ref->{$chrom2}->{$breakpoint2}->{$strand2}) {
				try_split_and_align $genome, $chrom2, $pos2, $strand2, $breakpoint2, $seq2, $cigar2, $chrom, $pos, $strand, $seq, $id, $opt, $breakpoints_ref;
			}
		}
		close $file;
	}

	my $genome = load_genome $opt->{genome_fasta};
	process_paired_reads $opt->{input}, $opt, \%breakpoints, \%candidate_breakpoints, $genome;

	my @output_cols = ('chrom', 'pos', 'strand', 'chrom2', 'pos2', 'strand2', 'id');
	print $output join("\t", @output_cols), "\n";
	for my $key (sort { compare_genomic_coord2($a, $b) } keys %breakpoints) {
		for my $key2 (sort { compare_genomic_coord2($a, $b) } keys %{$breakpoints{$key}}) {
			for my $id (sort keys %{$breakpoints{$key}->{$key2}}) {
				print $output join("\t", split(':', $key), split(':', $key2), $id), "\n";
			}
		}
	}
	close $output;
}

#==========================================================#
# 'refine'

sub print_usage_refine
{
	print "
Usage: fuseek refine [options] <candidates.txt>

Options:
   -h / --help       show this help message
   -v / --verbose    show verbose messages
   <candidates.txt>  input text file (generated by 'identify')

Note:
   This step is supposed to refine fusion results (including breakpoints) by realignment.

";
	exit 1;
}

sub do_refine
{
	print_usage_refine unless @_;

	err "'refine' is still under development!"
}

#==========================================================#
# 'annotate'

sub print_usage_annotate
{
	print "
Usage: fuseek annotate [options] <fusions.txt>

Options:
   -h / --help     show this help message
   -v / --verbose  show verbose messages
   <fusions.txt>   input text file (generated by 'refine')

Note:
   This step is supposed to generate annotation (gene info) on fusion flunkings.

";
	exit 1;
}

sub do_annotate
{
	print_usage_annotate unless @_;

	err "'annotate' is still under development!"
}

#==========================================================#
# 'run'

my $def_opt_run = {
	verbose    => 0,
	input_bam  => '',
	out_prefix => ''
};

sub print_usage_run
{
	print "
Usage: fuseek run [options] <ref.fa> <refGene.gz> <in.bam> <out-prefix>

Options:
   -h / --help     show this help message
   -v / --verbose  show verbose messages
   <ref.fa>        reference genome in FASTA format
   <refGene.gz>    UCSC refGene annotation file
   <in.bam>        input (sorted) bam (generated by aligner like 'bwa')
   <out-prefix>    prefix (may contains directory name) of output files

";
	exit 1;
}

sub parse_opt_run
{
	my %opt = %{$def_opt_run};  # deep copy

	my @args = ();
	while (my $arg = shift) {
		if ($arg eq '-h' or $arg eq '--help') {
			print_usage_run
		} elsif ($arg eq '-v' or $arg eq '--verbose') {
			++$opt{verbose};
		} else {
			err "Unknown option '$arg'!" if $arg =~ /^-/;
			err "Unexpected parameter '$arg'!" if $#args == 3;
			push @args, $arg;
		}
	}
	print_usage_run unless $#args == 3;
	($opt{genome}, $opt{ref_gene}, $opt{input_bam}, $opt{out_prefix}) = @args;

	return \%opt;
}

sub do_run
{
	my $opt = parse_opt_run @_;

	my $dir = $opt->{out_prefix};
	if ($dir =~ /\//) {
		$dir =~ s/\/[^\/]*$//;
		ensure_directory $dir if $dir;
	}

	my $file0 = $opt->{input_bam};

	my $file1 = "$opt->{out_prefix}.01-discord.txt";
	die unless -e $file0;
	if (not -e $file1 or -M $file0 < -M $file1) {
		print STDERR "Generating '$file1'...\n";
		do_collect $file0, '-o', $file1;
	}

	my $file2 = "$opt->{out_prefix}.02-candidate.txt";
	die unless -e $file1;
	if (not -e $file2 or -M $file1 < -M $file2) {
		print STDERR "Generating '$file2'...\n";
		do_identify $file1, '-o', $file2, '-r', $opt->{ref_gene}, $opt->{genome};
	}

	print STDERR "Done.\n";
}

#==========================================================#

sub print_usage
{
	print "
Program: fuseek (FUsion SEEKer)
Version: 0.0.1

Usage:   fuseek <command> [options]

Commands:
   run        batch run (collect, identify, refine, annotate)
   collect    collect discordant reads from BAM file
   identify   identify fusions from discordant reads
   refine     refine breakpoints of fusions
   annotate   annotate fusions

";
	exit 1;
}

#----------------------------------------------------------#

print_usage unless @ARGV;

my $cmd = shift;
if ($cmd eq 'collect') {
	do_collect @ARGV;
} elsif ($cmd eq 'identify') {
	do_identify @ARGV;
} elsif ($cmd eq 'refine') {
	do_refine @ARGV;
} elsif ($cmd eq 'annotate') {
	do_refine @ARGV;
} elsif ($cmd eq 'run') {
	do_run @ARGV;
} else {
	err "Unknown command '$cmd'!";
}
